<?xml version="1.0" encoding="UTF-8" ?> 

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 

<mapper namespace="org.activiti.engine.impl.persistence.entity.JobEntityImpl">

  <!-- JOB DELETE STATEMENTS-->

  <delete id="deleteExecutableTimerJob" parameterType="org.activiti.engine.impl.persistence.entity.ExecutableTimerJobEntity">
    delete from ${prefix}ACT_RU_JOB where ID_ = #{id} and REV_ = #{revision}
  </delete>

    <delete id="deleteExecutableMessageJob" parameterType="org.activiti.engine.impl.persistence.entity.ExecutableMessageJobEntity">
    delete from ${prefix}ACT_RU_JOB where ID_ = #{id} and REV_ = #{revision}
  </delete>
  
  <delete id="bulkDeleteJob" parameterType="java.util.Collection">
    delete from ${prefix}ACT_RU_JOB where
     <foreach item="job" collection="list" index="index" separator=" or ">
        ID_ = #{job.id, jdbcType=VARCHAR}
    </foreach> 
  </delete>

  <delete id="deleteExecutableTimer" parameterType="org.activiti.engine.impl.persistence.entity.ExecutableTimerJobEntityImpl">
    delete from ${prefix}ACT_RU_JOB where ID_ = #{id} and REV_ = #{revision}
  </delete>

    <delete id="deleteExecutableMessage" parameterType="org.activiti.engine.impl.persistence.entity.ExecutableMessageJobEntityImpl">
        delete from ${prefix}ACT_RU_JOB where ID_ = #{id} and REV_ = #{revision}
    </delete>

    <delete id="deleteTimer" parameterType="org.activiti.engine.impl.persistence.entity.TimerEntityImpl">
      delete from ${prefix}ACT_RU_TIMER_JOB where ID_ = #{id} and REV_ = #{revision}
    </delete>
  
  <delete id="bulkDeleteTimer" parameterType="java.util.Collection">
    delete from ${prefix}ACT_RU_TIMER_JOB where
     <foreach item="job" collection="list" index="index" separator=" or ">
        ID_ = #{job.id, jdbcType=VARCHAR}
    </foreach> 
  </delete>

  <delete id="deleteMessage" parameterType="org.activiti.engine.impl.persistence.entity.JobEntityImpl">
    delete from ${prefix}ACT_RU_JOB where ID_ = #{id} and REV_ = #{revision}
  </delete>
  
  <delete id="bulkDeleteMessage" parameterType="java.util.Collection">
    delete from ${prefix}ACT_RU_JOB where
     <foreach item="job" collection="list" index="index" separator=" or ">
        ID_ = #{job.id, jdbcType=VARCHAR}
    </foreach> 
  </delete>
  
  <!-- JOB UPDATE STATEMENTS -->
  <update id="updateJobTenantIdForDeployment" parameterType="java.util.Map">
    update ${prefix}ACT_RU_JOB set
      TENANT_ID_ = #{tenantId, jdbcType=VARCHAR}
    where
      ID_ in (
        SELECT J.ID_ from ${prefix}ACT_RU_JOB J
        inner join ${prefix}ACT_RE_PROCDEF P on J.PROC_DEF_ID_  = P.ID_
        inner join ${prefix}ACT_RE_DEPLOYMENT D on P.DEPLOYMENT_ID_ = D.ID_ 
        where D.ID_ = #{deploymentId, jdbcType=VARCHAR}
      ) 
  </update>
  
  <update id="updateJobLockForAllJobs" parameterType="java.util.Map">
    update ${prefix}ACT_RU_JOB set
      LOCK_OWNER_ = #{lockOwner, jdbcType=VARCHAR},
      LOCK_EXP_TIME_ = #{lockExpirationTime, jdbcType=TIMESTAMP}
    where
      (RETRIES_ &gt; 0)
      and (DUEDATE_ is null or DUEDATE_ &lt;= #{dueDate, jdbcType=TIMESTAMP})
      and (LOCK_OWNER_ is null)
      
	 <!--  and (
	  	    (EXECUTION_ID_ is null)
	  		or 
	  		(PI.SUSPENSION_STATE_ = 1)
      ) 
        -->
  </update>
    
  <!-- See http://stackoverflow.com/questions/4429319/you-cant-specify-target-table-for-update-in-from-clause
       Tested this on MySQL 5.6: does NOT use a temporary table (so good, performance) -->
  <update id="updateJobTenantIdForDeployment" databaseId="mysql" parameterType="java.util.Map">
    update ${prefix}ACT_RU_JOB set
      TENANT_ID_ = #{tenantId, jdbcType=VARCHAR}
    where
      ID_ in (

          SELECT tempTask.tempId
          FROM (
                SELECT J.ID_ as tempId
                FROM  ${prefix}ACT_RU_JOB J
                inner join ${prefix}ACT_RE_PROCDEF P on J.PROC_DEF_ID_  = P.ID_
                inner join ${prefix}ACT_RE_DEPLOYMENT D on P.DEPLOYMENT_ID_ = D.ID_
                where D.ID_ = #{deploymentId, jdbcType=VARCHAR}

        ) AS tempTask

    )
  </update>
  
  <!-- JOB RESULTMAP (FOR TIMER AND MESSAGE) -->

  <resultMap id="jobResultMap" type="org.activiti.engine.impl.persistence.entity.JobEntityImpl">
    <id property="id" column="ID_" jdbcType="VARCHAR" />
    <result property="revision" column="REV_" jdbcType="INTEGER" />
    <result property="lockOwner" column="LOCK_OWNER_" jdbcType="VARCHAR" />
    <result property="lockExpirationTime" column="LOCK_EXP_TIME_" jdbcType="TIMESTAMP" />
    <result property="exclusive" column="EXCLUSIVE_" jdbcType="BOOLEAN" />
    <result property="executionId" column="EXECUTION_ID_" jdbcType="VARCHAR" />
    <result property="processInstanceId" column="PROCESS_INSTANCE_ID_" jdbcType="VARCHAR" />
    <result property="processDefinitionId" column="PROC_DEF_ID_" jdbcType="VARCHAR" />
    <result property="retries" column="RETRIES_" jdbcType="INTEGER" />
    <result property="exceptionByteArrayRef" column="EXCEPTION_STACK_ID_" typeHandler="ByteArrayRefTypeHandler" />
    <result property="exceptionMessage" column="EXCEPTION_MSG_" jdbcType="VARCHAR" />
    <result property="jobHandlerType" column="HANDLER_TYPE_" jdbcType="VARCHAR" />
    <result property="jobHandlerConfiguration" column="HANDLER_CFG_" jdbcType="VARCHAR" />
    <result property="tenantId" column="TENANT_ID_" jdbcType="VARCHAR" />
      <result property="duedate" column="DUEDATE_" jdbcType="TIMESTAMP" />
      <discriminator javaType="string" column="TYPE_">
      <case value="message" resultMap="messageResultMap"/> 
      <case value="timer" resultMap="timerResultMap"/> 
    </discriminator>
  </resultMap>

  <resultMap id="messageResultMap" type="org.activiti.engine.impl.persistence.entity.MessageEntityImpl" extends="jobResultMap">
  </resultMap>

  <resultMap id="timerResultMap" type="org.activiti.engine.impl.persistence.entity.TimerEntityImpl" extends="jobResultMap">
    <result property="repeat" column="REPEAT_" jdbcType="VARCHAR" />
  </resultMap>


    <resultMap id="executableJobResultMap" type="org.activiti.engine.impl.persistence.entity.ExecutableJobEntityImpl" extends="jobResultMap">
        <discriminator javaType="string" column="TYPE_">
            <case value="message" resultMap="executableMessageResultMap"/>
            <case value="timer" resultMap="executableTimerResultMap"/>
        </discriminator>
    </resultMap>


    <resultMap id="executableMessageResultMap" type="org.activiti.engine.impl.persistence.entity.ExecutableMessageJobEntityImpl" extends="executableJobResultMap">
    </resultMap>

    <resultMap id="executableTimerResultMap" type="org.activiti.engine.impl.persistence.entity.ExecutableTimerJobEntityImpl" extends="executableJobResultMap">
        <result property="repeat" column="REPEAT_" jdbcType="VARCHAR" />
    </resultMap>

    <resultMap id="lockedJobResultMap" type="org.activiti.engine.impl.persistence.entity.LockedJobEntityImpl" extends="jobResultMap">
        <discriminator javaType="string" column="TYPE_">
            <case value="message" resultMap="lockedMessageResultMap"/>
            <case value="timer" resultMap="lockedTimerResultMap"/>
        </discriminator>
    </resultMap>


    <resultMap id="lockedMessageResultMap" type="org.activiti.engine.impl.persistence.entity.LockedMessageJobEntityImpl" extends="lockedJobResultMap">
    </resultMap>

    <resultMap id="lockedTimerResultMap" type="org.activiti.engine.impl.persistence.entity.LockedTimerJobEntityImpl" extends="lockedJobResultMap">
        <result property="repeat" column="REPEAT_" jdbcType="VARCHAR" />
    </resultMap>



  <!-- JOB SELECT (FOR TIMER AND MESSAGE) -->  

  <select id="selectExecutableJob" parameterType="string" resultMap="executableJobResultMap">
    select * from ${prefix}ACT_RU_JOB where ID_ = #{id, jdbcType=VARCHAR}
  </select>


  <select id="selectNextJobsToExecute" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="executableJobResultMap">
  	${limitBefore}
    select 
    	RES.* ${limitBetween}    		
    from ${prefix}ACT_RU_JOB RES    
    	LEFT OUTER JOIN ${prefix}ACT_RU_EXECUTION PI ON PI.ID_ = RES.PROCESS_INSTANCE_ID_
    where (RES.RETRIES_ &gt; 0)
      and (RES.DUEDATE_ is null or RES.DUEDATE_ &lt;= #{parameter, jdbcType=TIMESTAMP})
	    and (
	  	    (RES.EXECUTION_ID_ is null)
	  		  or 
	  		  (PI.SUSPENSION_STATE_ = 1)
      )  
    ${limitAfter}	    
  </select>
  
  <select id="selectExecutableJobsDueToExecute" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="executableJobResultMap">
    ${limitBefore}
    select 
      RES.* ${limitBetween}       
    from ${prefix}ACT_RU_JOB RES    
      LEFT OUTER JOIN ${prefix}ACT_RU_EXECUTION PI ON PI.ID_ = RES.PROCESS_INSTANCE_ID_
    where RES.RETRIES_ &gt; 0
      and RES.DUEDATE_ is not null
      and RES.DUEDATE_ &lt;= #{parameter, jdbcType=TIMESTAMP}
      and (
          (RES.EXECUTION_ID_ is null)
          or 
          (PI.SUSPENSION_STATE_ = 1)
      )  
    ${limitAfter}     
  </select>
  
  <select id="selectExclusiveJobsToExecute" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
  	${limitBefore}
    select RES.* ${limitBetween} 
    from ${prefix}ACT_RU_JOB RES    
    where (RETRIES_ &gt; 0)
      and (DUEDATE_ is null or DUEDATE_ &lt;= #{parameter.now, jdbcType=TIMESTAMP})
      and (EXCLUSIVE_ = ${boolValue})
      and (PROCESS_INSTANCE_ID_ = #{parameter.pid})  
    ${limitAfter}
  </select>
  
  <select id="selectJobsByTypeAndProcessDefinitionId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
      select * from ${prefix}ACT_RU_JOB
      where HANDLER_TYPE_ = #{parameter.handlerType}
      and PROC_DEF_ID_ = #{parameter.processDefinitionId}
  </select>
  
  <select id="selectJobsByTypeAndProcessDefinitionIds" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
      select * from ${prefix}ACT_RU_JOB
      where HANDLER_TYPE_ = #{parameter.handlerType}
      <if test="parameter.processDefinitionIds != null">
		    and (<foreach item="processDefinitionId" collection="parameter.processDefinitionIds" index="index" separator=" or ">
		        PROC_DEF_ID_ = #{processDefinitionId, jdbcType=VARCHAR}
		    </foreach>)
      </if>
  </select>
  
  <select id="selectJobsByConfiguration" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
      select * from ${prefix}ACT_RU_JOB
      where HANDLER_TYPE_ = #{parameter.handlerType}
      and HANDLER_CFG_ like  #{parameter.handlerConfiguration}
  </select>

  <select id="selectExecutableJobsByExecutionId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="executableJobResultMap">
    select *
    from ${prefix}ACT_RU_JOB J
    where J.EXECUTION_ID_ = #{parameter}
  </select>
  
   <select id="selectJobByTypeAndProcessDefinitionKeyNoTenantId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="executableJobResultMap">
    select J.*
    from ${prefix}ACT_RU_JOB J
    inner join ${prefix}ACT_RE_PROCDEF P on J.PROC_DEF_ID_ = P.ID_
    where J.HANDLER_TYPE_ = #{parameter.handlerType} 
    and P.KEY_ = #{parameter.processDefinitionKey}
    and (P.TENANT_ID_ = ''  or P.TENANT_ID_ is null)  
  </select>
  
  <select id="selectJobByTypeAndProcessDefinitionKeyAndTenantId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="executableJobResultMap">
    select J.*
    from ${prefix}ACT_RU_JOB J
    inner join ${prefix}ACT_RE_PROCDEF P on J.PROC_DEF_ID_ = P.ID_
    where J.HANDLER_TYPE_ = #{parameter.handlerType} 
    and P.KEY_ = #{parameter.processDefinitionKey}
    and P.TENANT_ID_ = #{parameter.tenantId} 
  </select>
  
  <select id="selectExecutableJobByTypeAndProcessDefinitionId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="executableJobResultMap">
    select J.*
    from ${prefix}ACT_RU_JOB J
    where J.HANDLER_TYPE_ = #{parameter.handlerType}
    and J.PROC_DEF_ID_ = #{parameter.processDefinitionId} 
  </select>

    <select id="selectJobByQueryCriteria" parameterType="org.activiti.engine.impl.JobQueryImpl" resultMap="executableJobResultMap">
  	${limitBefore}
    select RES.* ${limitBetween}
    <include refid="selectJobByQueryCriteriaSql"/>
    ${orderBy}
    ${limitAfter}
  </select>

  <select id="selectJobCountByQueryCriteria" parameterType="org.activiti.engine.impl.JobQueryImpl" resultType="long">
    select count(distinct RES.ID_)
    <include refid="selectJobByQueryCriteriaSql"/>
  </select>

  <sql id="selectJobByQueryCriteriaSql">
    from ${prefix}ACT_RU_JOB RES
    <if test="executable">
        LEFT OUTER JOIN ${prefix}ACT_RU_EXECUTION PI ON PI.ID_ = RES.PROCESS_INSTANCE_ID_
    </if>
    <where>
      <if test="id != null">
        RES.ID_ = #{id}
      </if>
      <if test="processInstanceId != null">
        and RES.PROCESS_INSTANCE_ID_ = #{processInstanceId}
      </if>
      <if test="executionId != null">
        and RES.EXECUTION_ID_ = #{executionId}
      </if>
      <if test="processDefinitionId != null">
        and RES.PROC_DEF_ID_ = #{processDefinitionId}
      </if>
      <if test="retriesLeft">
        and RES.RETRIES_ &gt; 0
      </if>
      <if test="noRetriesLeft">
        and RES.RETRIES_ &lt;= 0
      </if>
      <if test="executable">
        and (RES.RETRIES_ &gt; 0)
        and (RES.DUEDATE_ is null or RES.DUEDATE_ &lt;= #{now, jdbcType=TIMESTAMP})
        and (
            (RES.EXECUTION_ID_ is null)
            or 
            (PI.SUSPENSION_STATE_ = 1)     
      )
      </if>
      <if test="onlyTimers">
        and RES.TYPE_ = 'timer'
      </if>
      <if test="onlyMessages">
        and RES.TYPE_ = 'message'
      </if>
      <if test="duedateHigherThan != null">
        and RES.DUEDATE_ &gt; #{duedateHigherThan}
      </if>
      <if test="duedateLowerThan != null">
        and RES.DUEDATE_ &lt; #{duedateLowerThan}
      </if>
      <if test="duedateHigherThanOrEqual != null">
        and RES.DUEDATE_ &gt;= #{duedateHigherThanOrEqual}
      </if>
      <if test="duedateLowerThanOrEqual != null">
        and RES.DUEDATE_ &lt;= #{duedateLowerThanOrEqual}
      </if>
      <if test="withException">
      	and (RES.EXCEPTION_MSG_ is not null or RES.EXCEPTION_STACK_ID_ is not null)
      </if>
      <if test="exceptionMessage">
      	and RES.EXCEPTION_MSG_ = #{exceptionMessage}
      </if>
      <if test="tenantId != null">
        and RES.TENANT_ID_ = #{tenantId}
      </if>
      <if test="tenantIdLike != null">
        and RES.TENANT_ID_ like #{tenantIdLike}
      </if>
      <if test="withoutTenantId">
        and (RES.TENANT_ID_ = '' or RES.TENANT_ID_ is null)
      </if>
    </where>
  </sql>

  <!-- TIMER INSERT -->

  <insert id="insertExecutableTimerJob" parameterType="org.activiti.engine.impl.persistence.entity.ExecutableTimerJobEntityImpl">
    insert into ${prefix}ACT_RU_JOB (
            ID_, 
            REV_,
            TYPE_,
            EXCLUSIVE_,
            EXECUTION_ID_, 
            PROCESS_INSTANCE_ID_,
            PROC_DEF_ID_,
            RETRIES_, 
            EXCEPTION_STACK_ID_,
            EXCEPTION_MSG_,
            DUEDATE_,
            REPEAT_,
            HANDLER_TYPE_,
            HANDLER_CFG_,
            TENANT_ID_)
    values (#{id, jdbcType=VARCHAR},
            1,
            #{jobType, jdbcType=VARCHAR},
            #{exclusive, jdbcType=BOOLEAN},
            #{executionId, jdbcType=VARCHAR},
            #{processInstanceId, jdbcType=VARCHAR},
            #{processDefinitionId, jdbcType=VARCHAR},
            #{retries, jdbcType=INTEGER},
            #{exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
            #{exceptionMessage, jdbcType=VARCHAR},
            #{duedate, jdbcType=TIMESTAMP},
            #{repeat, jdbcType=VARCHAR},
            #{jobHandlerType, jdbcType=VARCHAR},
            #{jobHandlerConfiguration, jdbcType=VARCHAR},
            #{tenantId, jdbcType=VARCHAR}
    )
  </insert>

  <insert id="insertTimer" parameterType="org.activiti.engine.impl.persistence.entity.TimerEntityImpl">
    insert into ${prefix}ACT_RU_TIMER_JOB (
            ID_,
            REV_,
            TYPE_,
            EXCLUSIVE_,
            EXECUTION_ID_,
            PROCESS_INSTANCE_ID_,
            PROC_DEF_ID_,
            RETRIES_,
            EXCEPTION_STACK_ID_,
            EXCEPTION_MSG_,
            DUEDATE_,
            REPEAT_,
            HANDLER_TYPE_,
            HANDLER_CFG_,
            TENANT_ID_)
    values (#{id, jdbcType=VARCHAR},
            1,
            'timer',
            #{exclusive, jdbcType=BOOLEAN},
            #{executionId, jdbcType=VARCHAR},
            #{processInstanceId, jdbcType=VARCHAR},
            #{processDefinitionId, jdbcType=VARCHAR},
            #{retries, jdbcType=INTEGER},
            #{exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
            #{exceptionMessage, jdbcType=VARCHAR},
            #{duedate, jdbcType=TIMESTAMP},
            #{repeat, jdbcType=VARCHAR},
            #{jobHandlerType, jdbcType=VARCHAR},
            #{jobHandlerConfiguration, jdbcType=VARCHAR},
            #{tenantId, jdbcType=VARCHAR}
    )
  </insert>

  <insert id="bulkInsertTimer" parameterType="java.util.List">
    INSERT INTO ${prefix}ACT_RU_TIMER_JOB (
            ID_, 
            REV_,
            TYPE_,
            EXCLUSIVE_,
            EXECUTION_ID_, 
            PROCESS_INSTANCE_ID_,
            PROC_DEF_ID_,
            RETRIES_, 
            EXCEPTION_STACK_ID_,
            EXCEPTION_MSG_,
            DUEDATE_,
            REPEAT_,
            HANDLER_TYPE_,
            HANDLER_CFG_,
            TENANT_ID_) VALUES 
    <foreach collection="list" item="job" index="index" separator=","> 
        (#{job.id, jdbcType=VARCHAR},
         1,
         #{job.jobType, jdbcType=VARCHAR},
         #{job.exclusive, jdbcType=BOOLEAN},
         #{job.executionId, jdbcType=VARCHAR},
         #{job.processInstanceId, jdbcType=VARCHAR},
         #{job.processDefinitionId, jdbcType=VARCHAR},
         #{job.retries, jdbcType=INTEGER},
         #{job.exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
         #{job.exceptionMessage, jdbcType=VARCHAR},
         #{job.duedate, jdbcType=TIMESTAMP},
         #{job.repeat, jdbcType=VARCHAR},
         #{job.jobHandlerType, jdbcType=VARCHAR},
         #{job.jobHandlerConfiguration, jdbcType=VARCHAR},
         #{job.tenantId, jdbcType=VARCHAR})
    </foreach>
  </insert>

  <insert id="bulkInsertTimer" databaseId="oracle" parameterType="java.util.List">
    INSERT ALL 
    <foreach collection="list" item="job" index="index"> 
      INTO ${prefix}ACT_RU_TIMER_JOB (
              ID_, 
              REV_,
              TYPE_,
              EXCLUSIVE_,
              EXECUTION_ID_, 
              PROCESS_INSTANCE_ID_,
              PROC_DEF_ID_,
              RETRIES_, 
              EXCEPTION_STACK_ID_,
              EXCEPTION_MSG_,
              DUEDATE_,
              REPEAT_,
              HANDLER_TYPE_,
              HANDLER_CFG_,
              TENANT_ID_) VALUES 
          (#{job.id, jdbcType=VARCHAR},
           1,
           #{job.jobType, jdbcType=VARCHAR},
           #{job.exclusive, jdbcType=BOOLEAN},
           #{job.executionId, jdbcType=VARCHAR},
           #{job.processInstanceId, jdbcType=VARCHAR},
           #{job.processDefinitionId, jdbcType=VARCHAR},
           #{job.retries, jdbcType=INTEGER},
           #{job.exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
           #{job.exceptionMessage, jdbcType=VARCHAR},
           #{job.duedate, jdbcType=TIMESTAMP},
           #{job.repeat, jdbcType=VARCHAR},
           #{job.jobHandlerType, jdbcType=VARCHAR},
           #{job.jobHandlerConfiguration, jdbcType=VARCHAR},
           #{job.tenantId, jdbcType=VARCHAR})
    </foreach>
    SELECT * FROM dual
  </insert>

  <!-- TIMER UPDATE -->

  <update id="updateExecutableTimerJob" parameterType="org.activiti.engine.impl.persistence.entity.ExecutableTimerJobEntityImpl">
    update ${prefix}ACT_RU_JOB
    <set>
       REV_ =  #{revisionNext, jdbcType=INTEGER},
       RETRIES_ = #{retries, jdbcType=INTEGER},
       EXCEPTION_STACK_ID_ = #{exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
       EXCEPTION_MSG_ = #{exceptionMessage, jdbcType=VARCHAR},
       DUEDATE_ = #{duedate, jdbcType=TIMESTAMP}
    </set>
    where ID_= #{id, jdbcType=VARCHAR}
      and REV_ = #{revision, jdbcType=INTEGER}
  </update>
  
  <!-- TIMER SELECT -->

  <select id="selectTimersByExecutionId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
    select * 
    from ${prefix}ACT_RU_JOB 
    where (RETRIES_ &gt; 0)
      and (TYPE_ = 'timer')
      and (EXECUTION_ID_ = #{parameter})
  </select>
  

  <!-- MESSAGE INSERT -->

  <insert id="insertExecutableMessageJob" parameterType="org.activiti.engine.impl.persistence.entity.MessageEntityImpl">
    insert into ${prefix}ACT_RU_JOB (
            ID_, 
            REV_, 
            TYPE_,
            EXCLUSIVE_,
            EXECUTION_ID_, 
            PROCESS_INSTANCE_ID_,
            PROC_DEF_ID_,
            DUEDATE_,
            RETRIES_, 
            EXCEPTION_STACK_ID_,
            EXCEPTION_MSG_,
            HANDLER_TYPE_,
            HANDLER_CFG_,
            TENANT_ID_)
    values (#{id, jdbcType=VARCHAR},
            1,
            'message',
            #{exclusive, jdbcType=BOOLEAN},
            #{executionId, jdbcType=VARCHAR},
            #{processInstanceId, jdbcType=VARCHAR},
            #{processDefinitionId, jdbcType=VARCHAR},
            #{duedate, jdbcType=TIMESTAMP},
            #{retries, jdbcType=INTEGER},
            #{exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
            #{exceptionMessage, jdbcType=VARCHAR},
            #{jobHandlerType, jdbcType=VARCHAR},
            #{jobHandlerConfiguration, jdbcType=VARCHAR},
            #{tenantId, jdbcType=VARCHAR}
    )
  </insert>
  
  <!-- MESSAGE UPDATE -->
  
  <update id="updateExecutableMessageJob" parameterType="org.activiti.engine.impl.persistence.entity.MessageEntityImpl">
    update ${prefix}ACT_RU_JOB
    <set>
       REV_ =  #{revisionNext, jdbcType=INTEGER},
       LOCK_EXP_TIME_ = #{lockExpirationTime, jdbcType=TIMESTAMP},
       LOCK_OWNER_ = #{lockOwner, jdbcType=VARCHAR},
       RETRIES_ = #{retries, jdbcType=INTEGER},
       EXCEPTION_STACK_ID_ = #{exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
       EXCEPTION_MSG_ = #{exceptionMessage, jdbcType=VARCHAR},
       DUEDATE_ = #{duedate, jdbcType=TIMESTAMP}
    </set>
    where ID_= #{id, jdbcType=VARCHAR}
      and REV_ = #{revision, jdbcType=INTEGER}
  </update>


    <insert id="bulkInsertExecutableTimerJob" parameterType="java.util.List">
        INSERT INTO ${prefix}ACT_RU_JOB (
        ID_,
        REV_,
        TYPE_,
        EXCLUSIVE_,
        EXECUTION_ID_,
        PROCESS_INSTANCE_ID_,
        PROC_DEF_ID_,
        RETRIES_,
        EXCEPTION_STACK_ID_,
        EXCEPTION_MSG_,
        DUEDATE_,
        REPEAT_,
        HANDLER_TYPE_,
        HANDLER_CFG_,
        TENANT_ID_) VALUES
        <foreach collection="list" item="job" index="index" separator=",">
            (#{job.id, jdbcType=VARCHAR},
            #{job.revision, jdbcType=INTEGER},
            'timer',
            #{job.exclusive, jdbcType=BOOLEAN},
            #{job.executionId, jdbcType=VARCHAR},
            #{job.processInstanceId, jdbcType=VARCHAR},
            #{job.processDefinitionId, jdbcType=VARCHAR},
            #{job.retries, jdbcType=INTEGER},
            #{job.exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
            #{job.exceptionMessage, jdbcType=VARCHAR},
            #{job.duedate, jdbcType=TIMESTAMP},
            #{job.repeat, jdbcType=VARCHAR},
            #{job.jobHandlerType, jdbcType=VARCHAR},
            #{job.jobHandlerConfiguration, jdbcType=VARCHAR},
            #{job.tenantId, jdbcType=VARCHAR})
        </foreach>
    </insert>

    <insert id="bulkInsertExecutableTimerJob" databaseId="oracle" parameterType="java.util.List">
        INSERT ALL
        <foreach collection="list" item="job" index="index">
            INTO ${prefix}ACT_RU_JOB (
            ID_,
            REV_,
            TYPE_,
            EXCLUSIVE_,
            EXECUTION_ID_,
            PROCESS_INSTANCE_ID_,
            PROC_DEF_ID_,
            RETRIES_,
            EXCEPTION_STACK_ID_,
            EXCEPTION_MSG_,
            DUEDATE_,
            REPEAT_,
            HANDLER_TYPE_,
            HANDLER_CFG_,
            TENANT_ID_) VALUES
            (#{job.id, jdbcType=VARCHAR},
            #{job.revision, jdbcType=INTEGER},
            'timer',
            #{job.exclusive, jdbcType=BOOLEAN},
            #{job.executionId, jdbcType=VARCHAR},
            #{job.processInstanceId, jdbcType=VARCHAR},
            #{job.processDefinitionId, jdbcType=VARCHAR},
            #{job.retries, jdbcType=INTEGER},
            #{job.exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
            #{job.exceptionMessage, jdbcType=VARCHAR},
            #{job.duedate, jdbcType=TIMESTAMP},
            #{job.repeat, jdbcType=VARCHAR},
            #{job.jobHandlerType, jdbcType=VARCHAR},
            #{job.jobHandlerConfiguration, jdbcType=VARCHAR},
            #{job.tenantId, jdbcType=VARCHAR})
        </foreach>
        SELECT * FROM dual
    </insert>

    <insert id="bulkInsertExecutableMessageJob" parameterType="java.util.List">
        INSERT INTO ${prefix}ACT_RU_JOB (
        ID_,
        REV_,
        TYPE_,
        EXCLUSIVE_,
        EXECUTION_ID_,
        PROCESS_INSTANCE_ID_,
        PROC_DEF_ID_,
        DUEDATE_,
        RETRIES_,
        EXCEPTION_STACK_ID_,
        EXCEPTION_MSG_,
        HANDLER_TYPE_,
        HANDLER_CFG_,
        TENANT_ID_) VALUES
        <foreach collection="list" item="job" index="index" separator=",">
            (#{job.id, jdbcType=VARCHAR},
            1,
            #{job.jobType, jdbcType=VARCHAR},
            #{job.exclusive, jdbcType=BOOLEAN},
            #{job.executionId, jdbcType=VARCHAR},
            #{job.processInstanceId, jdbcType=VARCHAR},
            #{job.processDefinitionId, jdbcType=VARCHAR},
            #{job.duedate, jdbcType=TIMESTAMP},
            #{job.retries, jdbcType=INTEGER},
            #{job.exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
            #{job.exceptionMessage, jdbcType=VARCHAR},
            #{job.jobHandlerType, jdbcType=VARCHAR},
            #{job.jobHandlerConfiguration, jdbcType=VARCHAR},
            #{job.tenantId, jdbcType=VARCHAR})
        </foreach>
    </insert>

    <insert id="bulkInsertExecutableMessageJob" databaseId="oracle" parameterType="java.util.List">
        INSERT ALL
        <foreach collection="list" item="job" index="index">
            INTO ${prefix}ACT_RU_JOB (
            ID_,
            REV_,
            TYPE_,
            EXCLUSIVE_,
            EXECUTION_ID_,
            PROCESS_INSTANCE_ID_,
            PROC_DEF_ID_,
            DUEDATE_,
            RETRIES_,
            EXCEPTION_STACK_ID_,
            EXCEPTION_MSG_,
            HANDLER_TYPE_,
            HANDLER_CFG_,
            TENANT_ID_) VALUES
            (#{job.id, jdbcType=VARCHAR},
            1,
            #{job.jobType, jdbcType=VARCHAR},
            #{job.exclusive, jdbcType=BOOLEAN},
            #{job.executionId, jdbcType=VARCHAR},
            #{job.processInstanceId, jdbcType=VARCHAR},
            #{job.processDefinitionId, jdbcType=VARCHAR},
            #{job.duedate, jdbcType=TIMESTAMP},
            #{job.retries, jdbcType=INTEGER},
            #{job.exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
            #{job.exceptionMessage, jdbcType=VARCHAR},
            #{job.jobHandlerType, jdbcType=VARCHAR},
            #{job.jobHandlerConfiguration, jdbcType=VARCHAR},
            #{job.tenantId, jdbcType=VARCHAR})
        </foreach>
        SELECT * FROM dual
    </insert>

</mapper>
